<?php
/**
 * Client.php
 * Generated by PhpStorm - 07/2016
 * Project campaign-manager2
 * @author Beno!t POLASZEK
 **/

namespace BenTools\GuzzleQueued;

use GuzzleHttp\Client as Guzzle;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Promise\Promise;
use GuzzleHttp\Promise\PromiseInterface;
use Pheanstalk\Exception\ServerException AS PheanstalkException;
use Pheanstalk\Pheanstalk;
use Psr\Cache\CacheItemPoolInterface;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;

/**
 * @method ResponseInterface get($uri, array $options = [])
 * @method ResponseInterface head($uri, array $options = [])
 * @method ResponseInterface put($uri, array $options = [])
 * @method ResponseInterface post($uri, array $options = [])
 * @method ResponseInterface patch($uri, array $options = [])
 * @method ResponseInterface delete($uri, array $options = [])
 * @method PromiseInterface getAsync($uri, array $options = [])
 * @method PromiseInterface headAsync($uri, array $options = [])
 * @method PromiseInterface putAsync($uri, array $options = [])
 * @method PromiseInterface postAsync($uri, array $options = [])
 * @method PromiseInterface patchAsync($uri, array $options = [])
 * @method PromiseInterface deleteAsync($uri, array $options = [])
 */
class Client implements ClientInterface {

    /**
     * @var CacheItemPoolInterface
     */
    private $cachePool;

    /**
     * @var Guzzle
     */
    private $decoratedClient;

    /**
     * @var Pheanstalk
     */
    private $queue;

    /**
     * @var int
     */
    private $sleepMs;

    /**
     * Client constructor.
     * @param Guzzle                 $decoratedClient
     * @param CacheItemPoolInterface $cachePool
     * @param Pheanstalk             $queue
     * @param                        $sleepMs
     */
    public function __construct(Guzzle $decoratedClient, CacheItemPoolInterface $cachePool, Pheanstalk $queue, $sleepMs = 10000) {
        $this->decoratedClient = $decoratedClient;
        $this->cachePool       = $cachePool;
        $this->queue           = $queue;
        $this->sleepMs         = $sleepMs;
    }

    /**
     * @inheritDoc
     */
    public function send(RequestInterface $request, array $options = []) {
        return $this->decoratedClient->send($request, $options);
    }

    /**
     * @param RequestInterface $request
     * @return Promise
     */
    public function sendAsync(RequestInterface $request, array $options = []) {
        $requestId     = uniqid();
        $requestBag    = [
            'requestId' => $requestId,
            'request'   => $request,
            'options'   => $options,
            'response'  => null,
        ];
        $serializedBag = static::wrapRequestBag($requestBag);
        $jobId         = $this->queue->put($serializedBag);
        $item          = $this->cachePool->getItem($requestId);
        $item->set($serializedBag);
        $item->expiresAfter(3600);
        $this->cachePool->save($item);

        $promise = new Promise(function () use ($jobId, $requestId, &$promise) {

            try {
                while (true) {
                    try {
                        $this->queue->peek($jobId);     // No exception thrown -> the job is still active (not yet resolved)
                        usleep((int) $this->sleepMs);   // Wait a little to avoid CPU burn
                    }
                    catch (PheanstalkException $e) {

                        $item       = $this->cachePool->getItem($requestId);
                        $requestBag = static::unwrapRequestBag($item->get());

                        switch (true) {

                            case !empty($requestBag['response']) && $requestBag['response']->getStatusCode() < 400:
                                $promise->resolve($requestBag['response']);
                                break 2;

                            case !empty($requestBag['response']):
                                $promise->reject(RequestException::create($requestBag['request'], $requestBag['response']));
                                break 2;

                            default:
                                $promise->reject(new ConnectException('Unable to process request', $requestBag['request']));
                                break 2;
                        }

                    }

                }
            }
            catch (\Exception $e) {
                $promise->reject($e);
            }
        });
        return $promise;
    }

    /**
     * @inheritDoc
     */
    public function request($method, $uri = null, array $options = []) {
        return $this->decoratedClient->request($method, $uri, $options);
    }

    /**
     * @inheritDoc
     */
    public function requestAsync($method, $uri, array $options = []) {
        return $this->decoratedClient->requestAsync($method, $uri, $options);
    }

    /**
     * @inheritDoc
     */
    public function getConfig($option = null) {
        return $this->decoratedClient->getConfig($option);
    }

    public function __call($method, $args) {
        return call_user_func_array([$this->decoratedClient, $method], $args);
    }

    /**
     * @return Guzzle
     */
    public function getDecoratedClient() {
        return $this->decoratedClient;
    }

    /**
     * @param $string
     * @return array
     */
    public static function unwrapRequestBag($string) {
        $requestBag            = \GuzzleHttp\json_decode($string, true);
        $requestBag['request'] = \GuzzleHttp\Psr7\parse_request($requestBag['request']);

        if (!empty($requestBag['response'])) {
            $requestBag['response'] = \GuzzleHttp\Psr7\parse_response($requestBag['response']);
        }
        return $requestBag;
    }

    /**
     * @param $requestBag
     * @return string
     */
    public static function wrapRequestBag($requestBag) {
        $requestBag['request'] = $requestBag['request']->withRequestTarget((string) $requestBag['request']->getUri());
        $requestBag['request'] = \GuzzleHttp\Psr7\str($requestBag['request']);
        if (!empty($requestBag['response'])) {
            $requestBag['response'] = \GuzzleHttp\Psr7\str($requestBag['response']);
        }
        return \GuzzleHttp\json_encode($requestBag);
    }
}